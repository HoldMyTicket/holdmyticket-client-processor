(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["hmt_client_processor"] = factory();
	else
		root["hmt_client_processor"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/hmtclientprocessor.min.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/qs/index.js":
/*!*******************************************!*\
  !*** /Users/wes/node_modules/qs/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib */ \"../../node_modules/qs/lib/index.js\");\n\n\n//# sourceURL=webpack://hmt_client_processor//Users/wes/node_modules/qs/index.js?");

/***/ }),

/***/ "../../node_modules/qs/lib/index.js":
/*!***********************************************!*\
  !*** /Users/wes/node_modules/qs/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Load modules\n\nvar Stringify = __webpack_require__(/*! ./stringify */ \"../../node_modules/qs/lib/stringify.js\");\nvar Parse = __webpack_require__(/*! ./parse */ \"../../node_modules/qs/lib/parse.js\");\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n\n//# sourceURL=webpack://hmt_client_processor//Users/wes/node_modules/qs/lib/index.js?");

/***/ }),

/***/ "../../node_modules/qs/lib/parse.js":
/*!***********************************************!*\
  !*** /Users/wes/node_modules/qs/lib/parse.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Load modules\n\nvar Utils = __webpack_require__(/*! ./utils */ \"../../node_modules/qs/lib/utils.js\");\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!obj.hasOwnProperty(key)) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj = {};\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        var indexString = '' + index;\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            indexString === cleanRoot &&\n            index <= options.arrayLimit) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Don't allow them to overwrite object prototype properties\n\n    if (Object.prototype.hasOwnProperty(segment[1])) {\n        return;\n    }\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            keys.push(segment[1]);\n        }\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return {};\n    }\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj);\n    }\n\n    return Utils.compact(obj);\n};\n\n\n//# sourceURL=webpack://hmt_client_processor//Users/wes/node_modules/qs/lib/parse.js?");

/***/ }),

/***/ "../../node_modules/qs/lib/stringify.js":
/*!***************************************************!*\
  !*** /Users/wes/node_modules/qs/lib/stringify.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Load modules\n\nvar Utils = __webpack_require__(/*! ./utils */ \"../../node_modules/qs/lib/utils.js\");\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&'\n};\n\n\ninternals.stringify = function (obj, prefix) {\n\n    if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys = Object.keys(obj);\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n        values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']'));\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n\n    var keys = [];\n\n    var objKeys = Object.keys(obj);\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n        keys = keys.concat(internals.stringify(obj[key], key));\n    }\n\n    return keys.join(delimiter);\n};\n\n\n//# sourceURL=webpack://hmt_client_processor//Users/wes/node_modules/qs/lib/stringify.js?");

/***/ }),

/***/ "../../node_modules/qs/lib/utils.js":
/*!***********************************************!*\
  !*** /Users/wes/node_modules/qs/lib/utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Load modules\n\n\n// Declare internals\n\nvar internals = {};\n\n\nexports.arrayToObject = function (source) {\n\n    var obj = {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        target.push(source);\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        target = [target].concat(source);\n        return target;\n    }\n\n    if (Array.isArray(target) &&\n        !Array.isArray(source)) {\n\n        target = exports.arrayToObject(target);\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (!target[key]) {\n            target[key] = value;\n        }\n        else {\n            target[key] = exports.merge(target[key], value);\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, l = obj.length; i < l; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (obj === null ||\n        typeof obj === 'undefined') {\n\n        return false;\n    }\n\n    return !!(obj.constructor &&\n        obj.constructor.isBuffer &&\n        obj.constructor.isBuffer(obj));\n};\n\n\n//# sourceURL=webpack://hmt_client_processor//Users/wes/node_modules/qs/lib/utils.js?");

/***/ }),

/***/ "./build/hmtclientprocessor.min.js":
/*!*****************************************!*\
  !*** ./build/hmtclientprocessor.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _qs = _interopRequireDefault(__webpack_require__(/*! qs */ \"../../node_modules/qs/index.js\"));\n\nvar hmt_client_processor = function hmt_client_processor(settings) {\n  this.api_url = settings.api_url || ''; // set when the script is loaded\n\n  this.api_url_suffix = settings.api_url_suffix || ''; // set when the script is loaded\n\n  this.env = settings.env || ''; // set when the script is loaded\n\n  this.app_type = settings.app_type || ''; // set prior to submit (online | box)\n\n  this.isHmtMobile = settings.isHmtMobile || false;\n  this.auth = settings.app_type == 'box' && settings.auth || '';\n  this.errors_internal = []; // errors to handle internally\n\n  this.errors_processing = []; // errors to send back to clients regarding processing status\n\n  this.country_codes = {\n    '2': 'US',\n    '3': 'AI',\n    '4': 'AR',\n    '5': 'AU',\n    '6': 'AT',\n    '7': 'BE',\n    '8': 'BR',\n    '9': 'CA',\n    '10': 'CL',\n    '11': 'C2',\n    '12': 'CR',\n    '13': 'CY',\n    '14': 'CZ',\n    '15': 'DK',\n    '16': 'DO',\n    '17': 'EC',\n    '18': 'EE',\n    '19': 'FI',\n    '20': 'FR',\n    '21': 'DE',\n    '22': 'GR',\n    '23': 'HK',\n    '24': 'HU',\n    '25': 'IS',\n    '26': 'IN',\n    '27': 'IE',\n    '28': 'IL',\n    '29': 'IT',\n    '30': 'JM',\n    '31': 'JP',\n    '32': 'LV',\n    '33': 'LT',\n    '34': 'LU',\n    '35': 'MY',\n    '36': 'MT',\n    '37': 'MX',\n    '38': 'NL',\n    '39': 'NZ',\n    '40': 'NO',\n    '41': 'PL',\n    '42': 'PT',\n    '43': 'SG',\n    '44': 'SK',\n    '45': 'SI',\n    '46': 'ZA',\n    '47': 'KR',\n    '48': 'ES',\n    '49': 'SE',\n    '50': 'CH',\n    '51': 'TW',\n    '52': 'TH',\n    '53': 'TR',\n    '54': 'GB',\n    '55': 'UY',\n    '56': 'VE',\n    '57': 'PE',\n    '58': 'GT',\n    '59': 'SL',\n    '60': 'AL',\n    '61': 'DZ',\n    '62': 'AD',\n    '63': 'AO',\n    '64': 'AG',\n    '65': 'AM',\n    '66': 'AW',\n    '67': 'AZ',\n    '68': 'BS',\n    '69': 'BH',\n    '70': 'BB',\n    '71': 'BZ',\n    '72': 'BJ',\n    '73': 'BM',\n    '74': 'BT',\n    '75': 'BO',\n    '76': 'BA',\n    '77': 'BW',\n    '78': 'VG',\n    '79': 'BN',\n    '80': 'BG',\n    '81': 'BF',\n    '82': 'BI',\n    '83': 'KH',\n    '84': 'CV',\n    '85': 'KY',\n    '86': 'TD',\n    '87': 'CO',\n    '88': 'KM',\n    '89': 'CK',\n    '90': 'HR',\n    '91': 'CD',\n    '92': 'DJ',\n    '93': 'DM',\n    '94': 'SV',\n    '95': 'ER',\n    '96': 'ET',\n    '97': 'FK',\n    '98': 'FO',\n    '99': 'FM',\n    '100': 'FJ',\n    '101': 'GF',\n    '102': 'PF',\n    '103': 'GA',\n    '104': 'GM',\n    '105': 'GI',\n    '106': 'GL',\n    '107': 'GD',\n    '108': 'GP',\n    '109': 'GN',\n    '110': 'GW',\n    '111': 'GY',\n    '112': 'HN',\n    '113': 'ID',\n    '114': 'JO',\n    '115': 'KZ',\n    '116': 'KE',\n    '117': 'KI',\n    '118': 'KW',\n    '119': 'KG',\n    '120': 'LA',\n    '121': 'LS',\n    '122': 'LI',\n    '123': 'MG',\n    '124': 'MW',\n    '125': 'MV',\n    '126': 'ML',\n    '127': 'MH',\n    '128': 'MQ',\n    '129': 'MR',\n    '130': 'MU',\n    '131': 'YT',\n    '132': 'MN',\n    '133': 'MS',\n    '134': 'MA',\n    '135': 'MZ',\n    '136': 'NA',\n    '137': 'NR',\n    '138': 'NP',\n    '139': 'AN',\n    '140': 'NC',\n    '141': 'NI',\n    '142': 'NE',\n    '143': 'NU',\n    '144': 'NF',\n    '145': 'OM',\n    '146': 'PW',\n    '147': 'PA',\n    '148': 'PG',\n    '149': 'PH',\n    '150': 'PN',\n    '151': 'QA',\n    '152': 'CG',\n    '153': 'RE',\n    '154': 'RO',\n    '155': 'RU',\n    '156': 'RW',\n    '157': 'VC',\n    '158': 'WS',\n    '159': 'SM',\n    '160': 'ST',\n    '161': 'SA',\n    '162': 'SN',\n    '163': 'SC',\n    '164': 'SB',\n    '165': 'SO',\n    '166': 'LK',\n    '167': 'SH',\n    '168': 'KN',\n    '169': 'LC',\n    '170': 'PM',\n    '171': 'SR',\n    '172': 'SJ',\n    '173': 'SZ',\n    '174': 'TJ',\n    '175': 'TZ',\n    '176': 'TG',\n    '177': 'TO',\n    '178': 'TT',\n    '179': 'TN',\n    '180': 'TM',\n    '181': 'TC',\n    '182': 'TV',\n    '183': 'UG',\n    '184': 'UA',\n    '185': 'AE',\n    '186': 'VU',\n    '187': 'VA',\n    '188': 'VN',\n    '189': 'WF',\n    '190': 'YE',\n    '191': 'ZM'\n  };\n\n  this.url = function (endpoint, use_suffix) {\n    return this.api_url + endpoint + (use_suffix ? this.api_url_suffix : '');\n  };\n\n  this.spreedly_url = function (spreedly_environment_key) {\n    return 'https://core.spreedly.com/v1/payment_methods.json?environment_key=' + spreedly_environment_key;\n  };\n\n  this.fullsteam_url = function () {\n    return 'https://api' + (this.env == 'local' || this.env == 'dev' || this.env == 'staging' ? '-ext' : '') + '.fullsteampay.net/';\n  };\n  /*\n  PUBLIC FUNCTIONS\n  */\n  // main function that the client will call to submit transactions\n\n\n  this.submit_transaction = function (card, transaction, cb) {\n    var _this = this;\n\n    this._clear_state();\n\n    transaction = this._prepare_transaction(transaction);\n\n    var response = function response(result, cb, transaction) {\n      var error = !result ? true : false;\n      var res = result ? result : {\n        status: 'error',\n        errors: _this.errors_processing // just pass back the cb_data here, and not everywhere else\n\n      };\n      if (transaction.cb_data) res.cb_data = transaction.cb_data; // log the bad response here\n\n      if (error) _this._log_bad_trans(transaction, res);\n\n      _this._respond(error, res, cb);\n    }; // determine the method to use spreedly | fullsteam\n\n\n    if (transaction.processor_method == 'spreedly') {\n      this._submit_spreedly(card, transaction, cb).then(function (result) {\n        response(result, cb, transaction);\n      });\n    } else if (transaction.processor_method == 'fullsteam') {\n      this._submit_fullsteam(card, transaction, cb).then(function (result) {\n        response(result, cb, transaction);\n      });\n    } else {\n      this._add_internal_error('No processing method setup');\n\n      response(false, cb);\n    }\n  }; // public fn, calling internal so internal can be async\n\n\n  this.save_card = function (card, transaction, processor, ticket_key) {\n    this._save_card(card, transaction, processor, ticket_key);\n  };\n\n  this.webuser_save_card = function (card, data, webuser_id, cb) {\n    this._webuser_save_card(card, data, webuser_id, cb);\n  };\n  /*\n  PRIVATE FUNCTIONS\n  */\n\n  /* SPREEDLY */\n\n\n  this._get_spreedly_env_key = function () {\n    if (this.spreedly_environment_key) return this.spreedly_environment_key;\n    if (config && config.spreedly_environment_key) return config.spreedly_environment_key;\n    return '';\n  };\n\n  this._submit_spreedly = function _callee(card, transaction) {\n    var token_res, transaction_res;\n    return _regenerator[\"default\"].async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!transaction.payment_token) {\n              _context.next = 4;\n              break;\n            }\n\n            _context.next = 3;\n            return _regenerator[\"default\"].awrap(this._submit_spreedly_transaction(transaction));\n\n          case 3:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 4:\n            _context.next = 6;\n            return _regenerator[\"default\"].awrap(this._get_spreedly_token(card, transaction.spreedly_environment_key));\n\n          case 6:\n            token_res = _context.sent;\n\n            if (!(!token_res || !token_res.transaction || !token_res.transaction.payment_method || !token_res.transaction.payment_method.token)) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\", this._add_internal_error('Spreedly, Could not get token'));\n\n          case 9:\n            transaction.payment_token = token_res.transaction.payment_method.token;\n            _context.next = 12;\n            return _regenerator[\"default\"].awrap(this._submit_spreedly_transaction(transaction));\n\n          case 12:\n            transaction_res = _context.sent;\n            if (transaction_res && transaction_res.ticket_key) this._save_card_to_webuser({\n              ticket_key: transaction_res.ticket_key\n            });\n            if (transaction.cc_retain && transaction.cc_retain == 'y') this._save_card(card, transaction, 'fullsteam');\n            return _context.abrupt(\"return\", transaction_res);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._get_spreedly_token = function _callee2(card, spreedly_environment_key, cb) {\n    var token;\n    return _regenerator[\"default\"].async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.spreedly_url(spreedly_environment_key),\n              type: 'POST',\n              withCredentials: false,\n              json: true,\n              data: card\n            }));\n\n          case 2:\n            token = _context2.sent;\n\n            if (token.errors && token.errors.length > 0) {\n              for (key in token.errors) {\n                this._add_processing_error(token.errors[key].message);\n              }\n            }\n\n            return _context2.abrupt(\"return\", token);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._submit_spreedly_transaction = function _callee3(transaction, cb) {\n    var transaction_res;\n    return _regenerator[\"default\"].async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (transaction.payments) transaction.payments = this._update_payments_token(transaction.payments, transaction.payment_token);\n            transaction = this._remove_sensitive_card_data(transaction);\n            _context3.next = 4;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.url('shop/carts/submit', true),\n              type: 'POST',\n              data: transaction,\n              form_encoded: true,\n              withCredentials: true\n            }));\n\n          case 4:\n            transaction_res = _context3.sent;\n            return _context3.abrupt(\"return\", transaction_res);\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, this);\n  };\n  /* FULLSTEAM */\n\n\n  this._submit_fullsteam = function _callee4(card, transaction, cb) {\n    var authentication_key_res, auth_key, token_res, transaction_res;\n    return _regenerator[\"default\"].async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!transaction.payment_token) {\n              _context4.next = 4;\n              break;\n            }\n\n            _context4.next = 3;\n            return _regenerator[\"default\"].awrap(this._submit_fullsteam_transaction(transaction));\n\n          case 3:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 4:\n            _context4.next = 6;\n            return _regenerator[\"default\"].awrap(this._get_fullsteam_auth_key());\n\n          case 6:\n            authentication_key_res = _context4.sent;\n            auth_key = null;\n            if (authentication_key_res && authentication_key_res.status && authentication_key_res.status == 'ok' && authentication_key_res.authenticationKey) auth_key = authentication_key_res.authenticationKey;\n            _context4.next = 11;\n            return _regenerator[\"default\"].awrap(this._get_fullsteam_token(card, transaction, auth_key));\n\n          case 11:\n            token_res = _context4.sent;\n\n            if (!(!token_res || !token_res.isSuccessful)) {\n              _context4.next = 14;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", false);\n\n          case 14:\n            transaction.payment_token = token_res.token;\n            if (transaction.payments) transaction.payments = this._update_payments_token(transaction.payments, transaction.payment_token);\n            _context4.next = 18;\n            return _regenerator[\"default\"].awrap(this._submit_fullsteam_transaction(transaction));\n\n          case 18:\n            transaction_res = _context4.sent;\n            if (transaction_res && transaction_res.ticket_key) this._save_card_to_webuser({\n              ticket_key: transaction_res.ticket_key\n            });\n\n            if (transaction.cc_retain && transaction.cc_retain == 'y') {\n              if (!transaction.spreedly_environment_key) transaction.spreedly_environment_key = this._get_spreedly_env_key();\n\n              this._save_card(card, transaction, 'spreedly');\n            }\n\n            return _context4.abrupt(\"return\", transaction_res);\n\n          case 22:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._get_fullsteam_auth_key = function _callee5() {\n    var token_res;\n    return _regenerator[\"default\"].async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.url('shop/processors/get_authentication_key', true)\n            }));\n\n          case 2:\n            token_res = _context5.sent;\n            return _context5.abrupt(\"return\", token_res);\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._get_fullsteam_token = function _callee6(card, transaction, auth_key, cb) {\n    var data, res, msg, key, issuerResponseCode, issuerResponseDescription, CVVResponseCode, CVVResponseDescription;\n    return _regenerator[\"default\"].async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!(!card || !card.payment_method || !card.payment_method.credit_card || !card.payment_method.credit_card.number || !card.payment_method.credit_card.month || !card.payment_method.credit_card.year || !card.payment_method.credit_card.full_name || !card.payment_method.credit_card.verification_value)) {\n              _context6.next = 3;\n              break;\n            }\n\n            this._add_processing_error('Missing required card inputs');\n\n            return _context6.abrupt(\"return\", false);\n\n          case 3:\n            data = {\n              \"clearTextCardData\": {\n                \"cardNumber\": card.payment_method.credit_card.number.replace(/\\s/g, ''),\n                \"cvv\": card.payment_method.credit_card.verification_value,\n                \"expirationMonth\": card.payment_method.credit_card.month,\n                \"expirationYear\": card.payment_method.credit_card.year,\n                \"billingInformation\": {\n                  \"nameOnAccount\": card.payment_method.credit_card.full_name,\n                  \"firstName\": transaction.f_name || null,\n                  \"lastName\": transaction.l_name || null,\n                  \"address1\": transaction.address1 || null,\n                  \"address2\": transaction.address2 || null,\n                  \"city\": transaction.city || null,\n                  \"state\": transaction.state || null,\n                  \"zip\": transaction.zip || (this.app_type == 'box' ? '00000' : null),\n                  \"country\": this._get_fullsteam_contry_code(transaction),\n                  \"phone\": transaction.phone || null,\n                  \"email\": transaction.email || null\n                }\n              },\n              \"cardEntryContext\": this.app_type == 'box' ? 7 : 5,\n              \"performAccountVerification\": true\n            };\n            if (transaction.country_id && transaction.country_id != '2') delete data.clearTextCardData.billingInformation.state;\n            _context6.next = 7;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.fullsteam_url() + 'api/token/card/clearText/create',\n              type: 'POST',\n              cors: true,\n              crossdomain: true,\n              data: data,\n              json: true,\n              withCredentials: false,\n              auth_key: auth_key\n            }));\n\n          case 7:\n            res = _context6.sent;\n\n            if (!(!res || !res.isSuccessful)) {\n              _context6.next = 16;\n              break;\n            }\n\n            this._add_internal_error('Fullsteam, Could not get token');\n\n            msg = '';\n\n            if (res && res.responseDetails) {\n              for (key in res.responseDetails) {\n                this._add_processing_error(res.responseDetails[key].message);\n              }\n            }\n\n            if (res && res.issuerResponseDetails) {\n              issuerResponseCode = res.issuerResponseDetails.issuerResponseCode || 0;\n              issuerResponseDescription = res.issuerResponseDetails.issuerResponseDescription || '';\n              CVVResponseCode = res.issuerResponseDetails.cvvResponseCode && ['M', 'P'].indexOf(res.issuerResponseDetails.cvvResponseCode) == -1 ? res.issuerResponseDetails.cvvResponseCode : 0;\n              CVVResponseDescription = CVVResponseCode && res.issuerResponseDetails.cvvResponseDescription ? res.issuerResponseDetails.cvvResponseDescription : ''; //we only look for cvv not M (match), P (not processed) cvv\n\n              if (CVVResponseDescription) {\n                msg = \"CVV Error: \" + CVVResponseDescription; //takes precedence\n              } else {\n                if (msg == '' && issuerResponseDescription) msg = \"Error: \" + issuerResponseDescription;\n                if (msg == '' && (!issuerResponseCode || issuerResponseCode == '00')) msg = \"CPE2: Missing error code\";\n                if (msg == '') msg = \"CPE3: Unknown issuer error\";\n              }\n            }\n\n            if (msg == '' && this.errors_processing.length == 0) msg = 'CPE4: Unknown processor error';\n\n            this._add_processing_error(msg);\n\n            return _context6.abrupt(\"return\", false);\n\n          case 16:\n            return _context6.abrupt(\"return\", res);\n\n          case 17:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._submit_fullsteam_transaction = function _callee7(transaction, cb) {\n    var transaction_res;\n    return _regenerator[\"default\"].async(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            transaction = this._remove_sensitive_card_data(transaction);\n            _context7.next = 3;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.url('shop/carts/submit', true),\n              type: 'POST',\n              data: transaction,\n              form_encoded: true,\n              withCredentials: true\n            }));\n\n          case 3:\n            transaction_res = _context7.sent;\n            return _context7.abrupt(\"return\", transaction_res);\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._get_fullsteam_contry_code = function (transaction) {\n    //country_id from HMT. return intnl country_code\n    var hmt_country_id = transaction.country_id || '2';\n    if (this.country_codes && this.country_codes[hmt_country_id]) return this.country_codes[hmt_country_id];\n    return 'US';\n  };\n  /* Card Saving Fns */\n\n\n  this._save_card = function _callee8(card, transaction, processor, ticket_key) {\n    var card_data, args, token_res, authentication_key_res, env_key;\n    return _regenerator[\"default\"].async(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!(!card || !card.payment_method || !card.payment_method.credit_card)) {\n              _context8.next = 2;\n              break;\n            }\n\n            return _context8.abrupt(\"return\");\n\n          case 2:\n            card_data = card.payment_method.credit_card;\n            args = {\n              card: card_data,\n              processor: processor\n            };\n            ticket_key = ticket_key || '';\n            if (ticket_key) args.ticket_key = ticket_key;\n\n            if (!(processor == 'spreedly')) {\n              _context8.next = 14;\n              break;\n            }\n\n            _context8.next = 9;\n            return _regenerator[\"default\"].awrap(this._get_spreedly_token(card, transaction.spreedly_environment_key));\n\n          case 9:\n            token_res = _context8.sent;\n\n            if (token_res) {\n              _context8.next = 12;\n              break;\n            }\n\n            return _context8.abrupt(\"return\");\n\n          case 12:\n            if (token_res.transaction && token_res.transaction.payment_method && token_res.transaction.payment_method.token) args.token = token_res.transaction.payment_method.token;\n\n            this._save_card_to_webuser(args);\n\n          case 14:\n            if (!(processor == 'fullsteam')) {\n              _context8.next = 23;\n              break;\n            }\n\n            _context8.next = 17;\n            return _regenerator[\"default\"].awrap(this._get_fullsteam_auth_key());\n\n          case 17:\n            authentication_key_res = _context8.sent;\n            env_key = null;\n            if (authentication_key_res && authentication_key_res.status && authentication_key_res.status == 'ok' && authentication_key_res.authenticationKey) env_key = authentication_key_res.authenticationKey;\n\n            if (env_key) {\n              _context8.next = 22;\n              break;\n            }\n\n            return _context8.abrupt(\"return\");\n\n          case 22:\n            this._get_fullsteam_token(card, transaction, env_key, function (err, token_res) {\n              if (!token_res || !token_res.isSuccessful || !token_res.token) return;\n              args.token = token_res.token;\n\n              this._save_card_to_webuser(args);\n            });\n\n          case 23:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._save_card_to_webuser = function _callee9(args) {\n    var card_data, data, res;\n    return _regenerator[\"default\"].async(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            this._remember_card_data(args);\n\n            card_data = this.card_data ? this._format_card_for_save(this.card_data) : null;\n\n            if (!(this.card_ticket_key && card_data && this.card_token && this.card_processor)) {\n              _context9.next = 7;\n              break;\n            }\n\n            data = {\n              ticket_key: this.card_ticket_key,\n              vault: this.card_processor,\n              token: this.card_token,\n              card_data: card_data\n            };\n            _context9.next = 6;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.url('public/orders/save_additional_card', false),\n              type: 'POST',\n              withCredentials: false,\n              data: data,\n              form_encoded: true\n            }));\n\n          case 6:\n            res = _context9.sent;\n\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, this);\n  };\n\n  this._webuser_save_card = function _callee10(card, data, webuser_id, cb) {\n    var res, spreedly_token_res, request_data, save_credit_card_res, authentication_key_res, env_key, fullsteam_token_res, card_data, save_additional_card_res;\n    return _regenerator[\"default\"].async(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            res = {}; // console.log('card: ', card)\n            // console.log('data: ', data)\n            // console.log('webuser_id: ', webuser_id)\n\n            _context10.next = 3;\n            return _regenerator[\"default\"].awrap(this._get_spreedly_token(card, data.spreedly_environment_key));\n\n          case 3:\n            spreedly_token_res = _context10.sent;\n\n            if (!(!spreedly_token_res || !spreedly_token_res.transaction || !spreedly_token_res.transaction.payment_method || !spreedly_token_res.transaction.payment_method.token)) {\n              _context10.next = 6;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", this._add_internal_error('Spreedly, Could not get token'));\n\n          case 6:\n            request_data = {\n              webuser_id: webuser_id,\n              token: spreedly_token_res.transaction.payment_method.token,\n              vault: 'spreedly'\n            };\n            _context10.next = 9;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.url('public/users/save_credit_card', false),\n              type: 'POST',\n              withCredentials: false,\n              data: request_data,\n              form_encoded: true\n            }));\n\n          case 9:\n            save_credit_card_res = _context10.sent;\n            // console.log('public/users/save_credit_card_res: ', save_credit_card_res)\n            if (save_credit_card_res && save_credit_card_res.status == 'ok' && save_credit_card_res.statusText == 'OK') res = save_credit_card_res;\n\n            if (!(!save_credit_card_res || !save_credit_card_res.status || save_credit_card_res.status != 'ok')) {\n              _context10.next = 13;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", this._add_internal_error('Error saving credit card'));\n\n          case 13:\n            _context10.next = 15;\n            return _regenerator[\"default\"].awrap(this._get_fullsteam_auth_key());\n\n          case 15:\n            authentication_key_res = _context10.sent;\n            env_key = null;\n            if (authentication_key_res && authentication_key_res.status && authentication_key_res.status == 'ok' && authentication_key_res.authenticationKey) env_key = authentication_key_res.authenticationKey;\n\n            if (env_key) {\n              _context10.next = 20;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", this._add_internal_error('Fullsteam, Could not get env_key'));\n\n          case 20:\n            if (!data.zip && card.payment_method.credit_card.zip) data.zip = card.payment_method.credit_card.zip;\n            _context10.next = 23;\n            return _regenerator[\"default\"].awrap(this._get_fullsteam_token(card, data, env_key));\n\n          case 23:\n            fullsteam_token_res = _context10.sent;\n\n            if (!(!fullsteam_token_res || !fullsteam_token_res.isSuccessful || !fullsteam_token_res.token)) {\n              _context10.next = 26;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", this._add_internal_error('Fullsteam, Could not get token'));\n\n          case 26:\n            card_data = card.payment_method.credit_card ? this._format_card_for_save(card.payment_method.credit_card) : null;\n            data = {\n              webuser_id: webuser_id,\n              vault: 'fullsteam',\n              token: fullsteam_token_res.token,\n              card_data: card_data\n            };\n            _context10.next = 30;\n            return _regenerator[\"default\"].awrap(this._request({\n              url: this.url('public/users/save_additional_card', false),\n              type: 'POST',\n              withCredentials: false,\n              data: data,\n              form_encoded: true\n            }));\n\n          case 30:\n            save_additional_card_res = _context10.sent;\n\n            if (!(!save_additional_card_res || !save_additional_card_res.status || save_additional_card_res.status != 'ok')) {\n              _context10.next = 33;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", this._add_internal_error('Error saving additional credit card'));\n\n          case 33:\n            // console.log('res: ', res)\n            this._respond(null, res, cb); // TODO: actually send errors if there are any? \n\n\n          case 34:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, this);\n  };\n  /*\n  Utilities\n  */\n\n\n  this._update_payments_token = function (payments, payment_token) {\n    //for split payments we need the token\n    for (var i = 0; i < payments.length; i++) {\n      var payment = payments[i];\n      if (payment.type == 'credit') payments[i].payment_token = payment_token;\n    }\n\n    return payments;\n  };\n\n  this._format_card_for_save = function (card_data) {\n    if (!card_data.full_name) return false;\n    if (!card_data.month) return false;\n    if (!card_data.year) return false;\n    if (!card_data.number) return false;\n    return {\n      full_name: card_data.full_name,\n      last_four: this._get_last_four(card_data.number),\n      exp_month: card_data.month,\n      exp_year: card_data.year\n    };\n  };\n\n  this._format_phone_number = function (phone_number) {\n    // \\D stands for any non digit\n    return phone_number.replace(/\\D/g, '');\n  };\n\n  this._get_last_four = function (cc_num) {\n    return cc_num.substr(cc_num.length - 4);\n  };\n\n  this._remember_card_data = function (args) {\n    if (args.card) this.card_data = args.card;\n    if (args.token) this.card_token = args.token;\n    if (args.processor) this.card_processor = args.processor;\n    if (args.ticket_key) this.card_ticket_key = args.ticket_key;\n  };\n\n  this._clear_state = function () {\n    this.errors_internal = [];\n    this.errors_processing = [];\n    delete this.card_data;\n    delete this.card_token;\n    delete this.processor;\n    delete this.card_ticket_key;\n  };\n\n  this._remove_sensitive_card_data = function (data) {\n    delete data.cc_no;\n    delete data.cc_cvc;\n    delete data.cc_expiry;\n    delete data.cc_name;\n    delete data.encryptedTrack1;\n    delete data.encryptedTrack2;\n    delete data.ksn;\n    return data;\n  };\n  /* \n  Main Request Fn\n  */\n\n\n  this._request = function _callee11(opts) {\n    var _this2 = this;\n\n    return _regenerator[\"default\"].async(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            return _context11.abrupt(\"return\", new Promise(function (resolve, reject) {\n              // default\n              var headers = {};\n              if (opts.json) headers['content-type'] = 'application/json;charset=UTF-8';\n\n              if (opts.form_encoded) {\n                headers['content-type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n\n                if (opts.data.payments) {\n                  var payments = opts.data.payments;\n                  delete opts.data.payments;\n\n                  var stringifiedPostData = _this2._serializer(opts.data);\n\n                  var stringifiedPayments = _this2._serializer({\n                    payments: payments\n                  });\n\n                  stringifiedPostData = stringifiedPostData + '&' + stringifiedPayments;\n                } else {\n                  var stringifiedPostData = _this2._serializer(opts.data);\n                }\n\n                opts.data = stringifiedPostData;\n              }\n\n              if (opts.auth_key) headers['authenticationKey'] = opts.auth_key;\n              var url = opts.url;\n              var data;\n              if (opts.data) data = opts.data;\n\n              if (_this2.auth && _this2.app_type == 'box' && url.indexOf('submit') > -1) {\n                url += (url.indexOf('?') > -1 ? '&' : '?') + 'auth=' + _this2.auth;\n                if ((0, _typeof2[\"default\"])(data) == 'object') data.can_handle_fullsteam = 'true';\n                if (typeof data == 'string') data += '&can_handle_fullsteam=true';\n              }\n\n              if (opts.json) data = JSON.stringify(data); // build the xhr request\n\n              var xhr = new XMLHttpRequest();\n              xhr.open(opts.type || 'GET', url);\n              xhr.withCredentials = opts.withCredentials || false;\n\n              for (key in headers) {\n                xhr.setRequestHeader(key, headers[key]);\n              }\n\n              xhr.onreadystatechange = function (evt) {\n                if (xhr.readyState === 4) {\n                  _this2._logger(url, data, xhr, opts);\n\n                  if (xhr.status && xhr.status >= 200 && xhr.status <= 299) resolve(_this2._xhr_success(xhr));else resolve(_this2._xhr_fail(xhr, url));\n                }\n              };\n\n              xhr.send(data);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    });\n  };\n  /* \n  Request Responses \n  */\n\n\n  this._xhr_success = function (xhr, opts) {\n    var res = {};\n\n    try {\n      res = JSON.parse(xhr.responseText);\n    } catch (error) {\n      console.log('could not parse the response to json');\n    } // attempt to set statusText\n\n\n    if (xhr.statusText) res.statusText = xhr.statusText; // react native seems to have a bug where the statusText comes through as undefined\n    // to get around it we'll set the prop manually for status 200 so we can pass any checks for it in the lib\n\n    if (this.isHmtMobile && !res.statusText) res.statusText = 'OK';\n    return res;\n  };\n\n  this._xhr_fail = function (xhr, url, opts) {\n    var error = null;\n\n    try {\n      error = JSON.parse(xhr.response);\n    } catch (error) {\n      console.log('could not parse error response');\n    }\n\n    var res = {};\n\n    try {\n      res = JSON.parse(xhr.responseText);\n    } catch (error) {\n      console.log('could not parse the response to json');\n    }\n\n    if (!res.status && res.status !== 'error') res.status = 'error';\n    res.statusText = xhr.statusText ? xhr.statusText : 'ERROR';\n    return res;\n  };\n\n  this._respond = function (err, res, cb) {\n    if (err || !res || res.status == 'error') {\n      this._throw_error(err, res, cb);\n\n      return;\n    }\n\n    if (cb) {\n      if (res.data) {\n        cb(null, res.data);\n      } else {\n        cb(null, res);\n      }\n    }\n  };\n\n  this._throw_error = function (err, res, cb) {\n    if (!err && res.msg) err = res.msg;\n    if (!err) err = true;\n    if (cb) cb(err, res);\n  };\n\n  this._logger = function (url, data, xhr, opts) {\n    try {\n      var d = {};\n      if (data && opts.json && typeof data == 'string') d = JSON.parse(data);\n      if (d.clearTextCardData) delete d.clearTextCardData;\n\n      var log = this._prepare_for_log({\n        url: url,\n        data: d,\n        xhr: {\n          // had to define these, can't stringify the raw xhr\n          readyState: xhr.readyState ? xhr.readyState : null,\n          response: xhr.response ? xhr.response : null,\n          responseText: xhr.responseText ? xhr.responseText : null,\n          responseURL: xhr.responseURL ? xhr.responseURL : null,\n          responseXML: xhr.responseXML ? xhr.responseXML : null,\n          status: xhr.status ? xhr.status : null,\n          statusText: xhr.statusText ? xhr.statusText : null,\n          timeout: xhr.timeout ? xhr.timeout : null\n        },\n        browser_info: this._get_browser_info()\n      });\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('POST', this.url('shop/processors/logme2342311', true), true);\n      xhr.withCredentials = true;\n      xhr.setRequestHeader('content-type', 'application/json;charset=UTF-8');\n      xhr.send(JSON.stringify(log));\n    } catch (error) {\n      // console.error so we can reference this in FullStory\n      console.error('CPE7 Logger Error', error);\n    }\n  };\n\n  this._log_bad_trans = function (transaction, response) {\n    try {\n      var d = {\n        form_data: transaction ? transaction : null,\n        transaction: transaction ? transaction : null\n      };\n      d.form_data.errors_internal = this.errors_internal;\n      d.form_data.errors_processing = this.errors_processing;\n      if (!d.transaction.processor) d.transaction.processor = {\n        merch_gateway: transaction.processor_method ? transaction.processor_method : null\n      };\n      d.transaction.error_msg = this.errors_processing.join(\"\\n\");\n      var xhr = new XMLHttpRequest();\n      xhr.open('POST', this.url('shop/carts/log_bad_trans', true), true);\n      xhr.withCredentials = true;\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n      xhr.send(this._serializer(d));\n    } catch (error) {\n      console.warn('Could not log bad trans');\n    }\n  };\n\n  this._prepare_for_log = function (data) {\n    var str = JSON.stringify(data); // mask cc data\n\n    str = str.replace(/\\b(?:\\d{4}[ -]?){3}(?=\\d{4}\\b)/gm, \"**** **** **** \");\n    return str;\n  };\n\n  this._get_browser_info = function () {\n    if (this.hmtMobile) return {\n      platform: 'hmtMobile'\n    };\n    return {\n      platform: navigator && navigator.platform ? navigator.platform : '',\n      userAgent: navigator && navigator.userAgent ? navigator.userAgent : '',\n      vendor: navigator && navigator.vendor ? navigator.vendor : '',\n      vendorSub: navigator && navigator.vendorSub ? navigator.vendorSub : ''\n    };\n  }; // deep serialize object to form data\n\n\n  this._serializer = function (obj) {\n    return _qs[\"default\"].stringify(obj, {\n      arrayFormat: 'repeat'\n    }); // var pairs = [];\n    // for (var prop in obj) {\n    //     if (!obj.hasOwnProperty(prop)) {\n    //         continue;\n    //     }\n    //     if (Object.prototype.toString.call(obj[prop]) == '[object Object]') {\n    //         pairs.push(this._serializer(obj[prop]));\n    //         continue;\n    //     }\n    //     pairs.push(prop + '=' + obj[prop]);\n    // }\n    // \n    // return pairs.join('&');\n  }; // prepare the transaction data prior to submitting\n\n\n  this._prepare_transaction = function (transaction) {\n    // removing all phone special chars. Only allow numbers\n    if (transaction.phone) transaction.phone = this._format_phone_number(transaction.phone);\n    return transaction;\n  }; // add a internal error\n\n\n  this._add_internal_error = function (err) {\n    this.errors_internal.push(err);\n    return false;\n  }; // add a processing error\n\n\n  this._add_processing_error = function (err) {\n    this.errors_processing.push(err);\n    return false;\n  };\n};\n\nvar _default = hmt_client_processor;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://hmt_client_processor/./build/hmtclientprocessor.min.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack://hmt_client_processor/./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\n\n//# sourceURL=webpack://hmt_client_processor/./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack://hmt_client_processor/./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js\");\n\n\n//# sourceURL=webpack://hmt_client_processor/./node_modules/@babel/runtime/regenerator/index.js?");

/***/ })

/******/ })["default"];
});